##### 编译器  调试器
    gcc 编译器
        注: 
            .c文件为源代码文件  
            .o文件为编译成机器码的文件,不一定能执行  
            含有main函数的.o或者其他文件才能执行
            .h文件为声明文件, 相当于注释说明文件
        使用:
            gcc 编译后的文件名.c  要编译的文件 (生成可执行文件)
            gcc -g 要调试的文件.c -o 编译后的文件.out (生成可调试文件)
            gcc a.c b.c c.c -o main.out (同时编译多个文件)        
            gcc -c max.c -o max.o
            
    gdb 调试器
        安装: yum -y install gdb (apt-get install gdb)
        使用:
            gdb 文件名.out  (进入文件调试)
            l 或者 list     (显示要调试的文件代码段)
            break 12        (设置要打断点的行号为第12行)
            start           (单步调试)
            n               (进入下一行)
            s               (进入当前行数)
            p a             (p为printf简写, 表示打印变量a)
            bt              (查看函数堆栈)
            f  1            (切换到栈#1)
            x/3d    0x7fffffffde1c  (从该地址开始打印三个变量)
            q               (退出调试)
            
    make 批量编译整理文件工具
        安装: yum -y install make (apt-get install make)
        使用:
            指定编译打包文件: Makefile
            
        // :左边为要生成的文件, 右边为所需要的文件, 下边为需要执行的命令, 
        // 用来操作右边的依赖文件生成左边的目标文件, 然后一直向下递归查找
        # 注释
        main.out:max.o min.o main.c     
            gcc max.o min.o main.c
        max.o:max.c
            gcc -c max.c
        min.o:min.c
            gcc -c min.c
        
    
##### c程序结构
    // 1. 包含头文件 预处理命令 
    // 作用: 通知C语言编译系统在对C程序进行正式编译之前需做一些预处理工作
    #include <stdio.h>
        <系统预装的源文件> 会在系统环境变量中查找文件
    
    #include "max.c"
        "自定义文件" 使用相对路径查找文件 
    
    
    // 2. 主函数
    c语言只有携带 main函数的文件才可以执行
    int main(int argv,char* argc[]) {
        return 0;
    }
    
    argv:
    
    argc[]:
        保存的是操作系统输入的命令行参数
    
    注意: c语言程序 main函数中的 return 0; 的作用, return其他数据都表示执行文件失败
    如果执行成功
        执行echo $? 会输出 0
    如果执行失败
        执行echo $? 会输出错误码
    
    
##### 结构体
    1. 预处理 (#include <stdio.h>)
        .c文件(预处理) ---> .i文件(编译) ---> .s文件(汇编) ---> .o文件(链接) ---> 可执行文件
        
        #include <stdio.h> 将stdio.h文件导入到c文件的头部展开
    
    2. 宏定义 (#define R 10)
       注:  
            1.宏在预处理阶段进行的是字符串替换
            2.宏不考虑c的语法
        #define R 10
        定义了一个R变量 为字符串10
        
        宏函数
        #define N(n) n*10;
        
        int a = 20;
        int b = N(a);  // int b = a*10;
        
        宏函数和正常函数的区别
        #define ADD(a,b) a+b     
        int add(int a, int b) {  
            return a+b;
        }
        
        ADD(a,b) * ADD(a,b)  // 相当于 a+b*a+b  因为预处理完才进行运算
        add(a,b) * add(a,b)  // 相当于 (a+b) * (a+b)
        
    3. typedef (typedef int a 给int起了个别名a)
        typedef int a;
        a num = 10; // int num = 10;
      
    4. 宏和typedef的区别
        宏没有作用域, 只要定义了, 下面都可以使用
        typedef有作用域, 需要在对应作用域中使用
        
    5. 结构体 (struct 可以存放不同类型的数据, 和数组相反)
        // 声明结构体 ,此时结构体只是一个模型, 没有分配内存
        struct a {
            char name[20];
            int atk;
            int price;
        }
        
        // 定义变量保存结构体
        struct a a1 = {"a1的名字", 100, 200};
        
        // 使用
        printf("%s\n,%d\n", a1.name, ++a1.atk, a1.price)
        
        // 结构体数组
        struct a a2 = { {"a1的名字", 50, 100}, {"a2的名字", 100, 200} };
        
        // 结构体指针
        // 指向结构体变量的指针变量
        struct 结构类型名称 * 结构指针变量名;
        
        // 指向结构体数组中指针的用法
        // 1. 声明结构体的指针变量*w
        struct a * w;
        // 2. 使该指针指向结构体变量a1
        w = a1;
        // 3. 使用该指针访问结构体中的成员
        printf("name=%s\n", (*w).name); // (*w) === w->name === a1.name
        
    // 6. 共用体 (union)
        特点: 共用一块内存地址, 所以初始化只能有一个常量, 共用体的长度 = 共用体中最长变量的字节长度
        union data {
            int a;
            char b;
            int c;
        }
        int main() {
            union data data_1;
            data_1.b = 'C';
            data_1.a = 10;  // 会覆盖上面的data_1.b  因为共用一块内存地址
        }
        
    // 偏移量
    结构体某变量的实际地址与结构体首地址的距离
    union data {
        int a;  // 偏移量 0
        char b; // 偏移量 4
        int c;  // 字节填充
    }
    
#####   指针结构与指针
    二者关系
        指针结构与指针的关系亦有两重: 其一是在定义结构时,将指针作为结构中的一个成员;
        其二是指向结构的指针(称为结构指针).前者同一般的结构成员一样可直接进行访问.
        结构指针说明的一般形式是：
            struct 结构类型名称 * 结构指针变量名;
            
##### 普通变量 指针 指针变量
    1. 普通变量
    
    2. 指针
        系统为每一个内存单元分配一个地址值, 这个地址值就是指针
        int i = 5; // 指针: &i
        
    3. 指针变量
        用于存放变量所占内存空间"首地址"的变量
        int *p = &i;    // 指针变量: *p   
        // 指针变量使用起来灵活，一个指针变量只占四个字节，但是它可以访问类似结构体，链表，数组等多数据集合，
        // 而且在访问这些变量的时候是对内存直接访问，执行效率更高
        
    4. 指针符号
        int *p; *p表示指针,  p保存的是变量的地址, *p表示*通过p这个地址去查找到指针*p保存的内存
        &p 中的&表示取地址符, 取指针变量的地址
        int tmp = *p; tmp表示指针变量, 里面保存的是指针保存的地址
        int *p = &a; 表示声明一个指针保存变量a的地址
        
        变量(内存) ---> 指针(保存内存地址) ---> 指针变量(保存指针) 
        
    5. 指针原理
    
    
            
##### 静态数据结构 和 动态数据结构(链表)
    头指针head ---> A ---> B ---> ... ---> 最后一个元素节点
    例: 静态链表
    struct weapon {
        int price;
        int atk;
        struct weapon * next;
    }
    int main() {
        struct weapon a,b,c, *head; // 声明链表的每一个节点
        a.price = 100;
        a.atk = 100;
        b.price = 200;
        b.atk = 200;
        c.price = 300;
        c.atk = 300;
        head = &a;  // 赋值链表的指向
        a.next = &b;
        b.next = &c;
        c.next = NULL;
    }
    
    例: 动态链表

##### 位运算
    位(二进制位)  0(false)  1(true)
    古老计算机: 位运算速度要比 + - 要快一些  比 * / 要快很多
    现代计算机: 位运算速度和 + - 一样 比 * / 要快
    
    位运算符
        &   按位与
            将参与运算的两个数据按对应的二进制数逐位进行运算
            
        |   按位或
        
        
        ^   按位异或
        
        
        ~   按位取反
        
        
        <<  左移
        
        
        >>  右移
    
        
  

##### 标识符(变量或函数名)
    1. 标识符可以是字母(A～Z，a～z)、数字(0～9)、下划线_组成的字符串，并且第一个字符必须是字母或下划线
    2. 标识符的长度最好不要超过8位
    3. 标识符是严格区分大小写的
    4. 标识符最好选择有意义的英文单词组成
    5. 标识符不能是C语言的关键字
    
##### 数据类型
    数据类型可分为：基本数据类型，构造数据类型，指针类型，空类型四大类
    
    1. 基本数据类型:
        1.1 整型: int  // (整型数据是指不带小数的数字)
                    作用: 2字节 用于存储整数
                    例子: int height = 18;
                    注: int、short int、long int是根据编译环境的不同，所取范围不同。
                
        1.2 字符型: char
                    作用: 1字节 用于存储单个字符  
                    例子: char sex = 'M';
                    
        1.3 实型(浮点型):   单精度型 双精度型 // (浮点数据是指带小数的数字)
        
                1.3.1 单精度型: float
                        作用: 4字节 用于存储小数
                        例子: float price  = 11.1;
                
                1.3.2 双精度型: double
                        作用: 8字节 用于存储位数更多的小数
                        例子: double p1 = 3.1415926;
            
        注: C语言中不存在字符串变量，字符串只能存在字符数组中 
        
    2. 构造类型
        2.1 枚举类型
        2.2 数组类型
        2.3 结构体类型
        2.4 共用体类型
        
    3. 指针类型
    
    4. 空类型
##### 常量
    #define 标识符 常量值
    
##### 自动类型转换
    自动转换发生在不同数据类型运算时，在编译的时候自动完成。
    字节小的可以向字节大的自动转换，但字节大的不能向字节小的自动转换
    
    char(1字节)  --->  自动转换 int float double
    int(2字节)   --->  自动转换 float double
    float(4字节) --->  自动转换 double
    
##### 强制类型转换
    强制类型转换是通过定义类型转换运算来实现的
    (数据类型) (表达式)
    int tempTwo = (int)tempOne;
    注意: 
    1. 数据类型和表达式都必须加括号, 如把(int)(x/2+y)写成(int)x/2+y则成了把x转换成int型之后再除2再与y相加了。
    2. 转换后不会改变原数据的类型及变量值，只在本次运算中临时性转换。
    3. 强制转换后的运算结果不遵循四舍五入原则。
    
##### 运算
    注意:
        1. 除法
            如果相除的两个数都是整数的话，则结果也为整数，小数部分省略，如8/3 = 2；而两数中有一个为小数，结果则为小数，如：9.0/2 = 4.500000。
        2. 取余
            该运算只适合用两个整数进行取余运算，如：10%3 = 1；而10.0%3则是错误的；运算后的符号取决于被模数的符号，如(-10)%3 = -1;而10%(-3) = 1。
            
##### 循环结构之三种循环比较
    while、do-while和for三种循环在具体的使用场合上是有区别的
    1、在知道循环次数的情况下更适合使用for循环；
    
    2、在不知道循环次数的情况下适合使用while或者do-while循环，
    如果有可能一次都不循环应考虑使用while循环，如果至少循环一次应考虑使用do-while循环。
    
##### break continue
    1、在没有循环结构的情况下，break不能用在单独的if-else语句中。

    2、在多层循环中，一个break语句只跳出当前循环。
    
    3. continue语句的作用是结束本次循环开始执行下一次循环。

    4. break语句与continue语句的区别是：break是跳出当前整个循环，continue结束本次循环开始下一次循环。 
    
##### 变量存储类别
    C语言根据变量的生存周期来划分，可以分为静态存储方式和动态存储方式。
    
    1. 静态存储方式：是指在程序运行期间分配固定的存储空间的方式。静态存储区中存放了在整个程序执行过程中都存在的变量，如全局变量。
    
    2. 动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。动态存储区中存放的变量是根据程序运行的需要而建立和释放的，通常包括：函数形式参数；自动变量；函数调用时的现场保护和返回地址等。
    
    3. C语言中存储类别又分为四类：自动（auto）、静态（static）、寄存器的（register）和外部的（extern）。
    
        3.1 用关键字auto定义的变量为自动变量，auto可以省略，auto不写则隐含定为“自动存储类别”，属于动态存储方式。
        如:  
            auto int b, c;
        
        3.2 用static修饰的为静态变量，如果定义在函数内部的，称之为静态局部变量；如果定义在函数外部，称之为静态外部变量。
        如下为静态局部变量：
            static int x = 0;
        
        注意：静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在程序整个运行期间都不释放；静态局部变量在编译时赋初值，即只赋初值一次；如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。
        
        3.3 为了提高效率，C语言允许将局部变量得值放在CPU中的寄存器中，这种变量叫“寄存器变量”，用关键字register作声明。
        例如：
            register int i;
            
        注意：只有局部自动变量和形式参数可以作为寄存器变量；一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；局部静态变量不能定义为寄存器变量。
        
        3.4 用extern声明的的变量是外部变量，外部变量的意义是某函数可以调用在该函数之后定义的变量。
        如：
            extern int x;
            
##### 数组
    0. 数组是相当类型变量的集合(只能存放同一种类型的数据) 
    1. 最好避免出现数组越界访问，循环变量最好不要超出数组的长度
    2. C语言的数组长度一经声明，长度就是固定，无法改变，并且C语言并不提供计算数组长度的方法。
    3. 数组当作函数参数
        3.1 整个数组当作函数参数，即把数组名称传入函数中
            void temp(int arr[]) {
                
            };
        3.2 组中的元素当作函数参数，即把数组中的参数传入函数中
            void temp(int arrValue) {
                
            };
        注意: 
            1. 数组名作为函数实参传递时，函数定义处作为接收参数的数组类型形参既可以指定长度也可以不指定长度。
            2. 数组元素作为函数实参传递时，数组元素类型必须与形参数据类型一致。