### 一、es6
#### 1. 新增数据类型
```
	Symbol	标识，相当于id，独一无二
	Set	一个去了重的数组，里面的元素唯一
	Map	一个可以使用对象当键的对象
```
	
#### Iterator迭代器
```
	一个类似链表结构的接口，可以使用for...of 循环遍历
```
	
#### Generator函数
```
	带*函数，yield为暂停，next获取每一步	return终结遍历Generator函数	
	Generator函数返回一个Iterator接口
```
	
#### 协程
```
	类似于进程，多个协程之间会进行执行权的交换
```

#### thunk函数
```
	将函数的多个参数，换成一个单参数回调函数，不使用就不计算，避免了正常传参的函数调用前计算，起到节省性能作用
```
	
#### let 变量 const 常量(值不可修改)

#### promise解决回调地狱
```
	resolve 成功   reject失败
	常用： 
		promise.all()  全部promise完成后触发
		promise.race() 只要有一个promise完成就立即触发,可以用于处理fetch链接超时问题
```
	
#### 事件和promise的区别
```
	事件：需要及时监听，错过了无结果
	promise: 状态可以保存，随时调用
```
	
#### await async 解决promise的链式调用烦恼，扁平化处理异步

#### 解构赋值
```
	省去赋值时用||来判断值是否存在等操作，更精简
```

#### rest
```
	函数的参数解构
```

#### fetch	axio  ajax
```
	fetch	axios	基于promise的请求
	ajax 基于js事件的请求
```
 
#### 装饰器 @
```
	给类添加额外的属性方法，常用：路由,redux,mobx,中间件，react高阶函数等

	@decorator
	class A {}
	相当于
	class A {}
	A = decorator(A) || A;
``` 


### 二、思维线: 普通函数 ---> 闭包 ---> return && new ---> 构造函数 && 原型 ---> 原型链 ---> 继承
#### 1. 闭包
```
	面试总结：闭包就是沟通函数外部和内部的桥梁。
	
	理解：
		起源：为了在函数的外部可以访问函数内部的局部变量
		特点：
			1. 可以在函数外部访问函数内部的变量，上下文信息。
			2. 可以保护函数中的上下文不被js垃圾回收机制回收。
		缺点：由于函数中的上下文不被js垃圾回收机制回收，会一直存在内存之中，暂用内存空间，造成浏览器性能问题。
		实现：return 函数中的函数
		function fn() {
			var a = 1;
			var function add {
				return a++;
			}
			// 桥梁 接口
			return add;
		}
		// 保护闭包内部变量不被销毁
		var a = fn();
		a(); // 1
		a(); // 2
		a(); // 3
```

####  2. new 构造函数 和 return 普通函数
```
	面试总结：1. new生成并return了一个新对象，this指向这个对象。2. return只是返回函数中已有对象，this指向window。

	理解：
		函数执行前加new对函数的影响:
		1. 函数内部会产生一个对象, this指向这个对象, 注意: 不是指向这个函数。(普通函数内部this指向null或者window)
		2. 函数默认返回这个对象 (所以不需要return)
		构造函数: 首字母大写, 使用new生成并返回一个新对象
		function Fn2() {
			// 注意, this不会指向fn2这个函数, 而是指向fn2内部产生的一个对象, 而obj通过=引用了该对象, 所以this指向了obj
			console.log(this); // obj	
		}
		var obj = new fn2();
		
		
		普通函数: 使用return返回函数中已有对象
		function fn1() {
			console.log(this); // window
			var obj = {};
			return obj;
		}
		fn1();
```
	
#### 3. 构造函数 和 原型
```
	面试总结：由于es5没有类，所以构造函数和原型用来模拟类，构造函数用来放实例化对象的私有属性，原型用来放实例化对象的公共属性。this指向实例化对象本身。

	理解：
		构造函数:
			构造函数内部的方法为每个new出来的新对象的 "私有属性"
			
		原型:
			prototype上的方法为所有对象的 "公共属性"
		
		实例对象:
			通过new关键字生成的对象
			
		function Factory(data) {
			// 实例对象的私有属性, 判断是否是私有属性 obj.hasOwnProperty(attr)
			this.data = data;
			console.log(this); // this执行实例化对象
		}
		
		// 构造函数的私有属性, 只能函数自己访问
		Factory.selfFn = function () {};
		
		// 公共属性
		Factory.prototype = {
			fn : function () {
				console.log(this); // this执行实例化对象
			}
		};
		
		var f1 = new Factory();
		var f2 = new Factory();
		
		所以,创建一个类的时候
			不同的部分, 每个实例对象都不一样的部分, 放在构造函数里面
			相同的部分, 每个实例对象都可以访问的部分, 放在原型里面
			
		注: 在构造函数中或者原型中, this指向的都是该实例化对象本身
```

#### 4. 原型链
```
	面试总结：一个对象在访问某属性时会先从自身查找, 找不到再去上一层的prototype找, 直到Object.prototype
	
	理解：
		访问某对象的方法
		function Factory() {}
		var f = new Factory();
		f.fn();
		
		原型链:
			先在实例化对象f自身查找fn
			然后到f的构造函数的原型中找fn
			然后到Object.prototype中找fn
			都找不到返回undefine
		
		一个对象在访问某属性时会先从自身查找, 找不到再去上一层的prototype找, 直到Object.prototype
```

#### 5. prototype 和 proto
```
	面试总结：每一个对象的__proto__就是该对象的构造函数的prototype

	理解：
		function Father() {}

		Father.prototype = {};

		var son = new Father();

		son.__proto__ === Father.prototype;

		son.__proto__.__proto__ === Object.prototype;
```

#### 6. instanceof 和 typeof 
```
	面试总结：typeof类型判断，instanceof继承判断
	
	理解：
		instanceof 
			a instanceof b 相当于 在a的__proto__上可以找到b.prototype
			
		typeof 
			数据类型判断
```

#### 7. 原型继承的几种方式
```
	注：在理解继承之前, 你需要理解 new prototype 构造函数和实例化对象的区别与联系 原型链
	
	7-1：原型继承(对象继承)
		面试总结：原型继承，不能传参，私有属性和公有属性都继承。
		
		理解：
			function Son() {};
		
			// 这里不能直接使用 Son.prototype = Father.prototype, 否则修改Son.prototype上的方法会改变Father.prototype上的
			Son.prototype = new Father();

			首先, 原型是一个对象, 它是不能传参的, 所以原型继承不能传参
			第二, new所产生的Father的实例化对象中, 都含有Father构造函数中的方法, 也有Father.prototype上的方法
			第三, 由于每一次new都会产生一个新的实例化对象, 互不影响, 所以原型继承的方法是可以复用的
			第四, 只能实现单继承, 继承Father或者Mother的实例
			
			总结: 原型继承, 不能传参, 父类构造函数(其实是从父类实例化对象上继承的,而不是直接从父类构造函数上继承的)和prototype中的方法都继承到了, 可以复用, 无法实现多继承
			
	7-2：构造函数继承(函数继承)
		面试总结：构造函数继承, 可以传参, 只继承了私有属性。	
		
		理解：
			function Son(param) {
				Father.call(this);
				Mother.call(this);
			}
			
			var son1 = new Son();
			var son2 = new Son();
			
			首先, 构造函数是一个函数, 是可以传参的, 所以构造函数可以传参
			第二, 无法继承父类prototype属性方法
			第三, 无法复用, 每个子类都生成一个父类实例, 消耗性能
			
			总结: 构造函数继承, 可以传参, 不能继承原型, 无法复用, 可以实现多继承
	
	7-3： 组合继承
		面试总结：组合继承, 可以传参, 私有属性和公有属性都继承了，但是私有属性继承了两次，消耗多余资源。
		
		理解：
			function Son(param) {
				Father.call(this);
				Mother.call(this);
			}
			
			Son.prototype = new Father(); // 原型继承会导致子类构造函数指向父类实例
			
			Son.prototype.constructor = Son; // 修复子类构造函数的指向
			
			首页, 可以传参
			第二, 可以继承函数和原型中的方法
			第三, 可以实现多继承
			第四, 结合7-1和7-2可以发现, 继承了两次构造函数(实际上是从实例化对象上继承的)中的方法, 一次原型中的方法, 消耗资源
			第五, 原型继承会导致子类构造函数指向父类实例, 需要修复子类构造函数的指向
			
			总结: 组合继承可以传参, 可以继承所有方法, 可以多继承, 但是构造函数中的方法继承了两次
			
	7-4： 寄生组合继承
		面试总结：寄生组合继承, 可以传参, 私有属性和公有属性都继承了，而且都只继承了一次，可以实现多继承。
		
		理解：
			function Son(param) {
				Father.call(this);
				Mother.call(this);
			}
			
			// 中介
			function F() {}
			F.prototype = Father.prototype;
			
			Son.prototype = new F();
			
			中介的作用: 通过中介只继承父类的prototype, 减少了多余的构造函数中的方法, 因为call已经继承了一次
			
			总结: 拥有以上三个继承所有的优点, 并且解决了构造函数方法继承了两次的问题
	
```

### 三、跨域
	面试总结：
		由于浏览器同源保护策略，协议，域名，端口，三者都相同，否则为跨域。
		常用跨域解决方案：JSONP，Proxy代理，nginx反向代理，cors，postMessage，document.domain等

#### 1. 产生的原因
```
	浏览器同源保护策略
	"源": 协议 域名 端口 三者都相同，否则为跨域
```

#### 2. 处理思路
```
	1. 只有协议不同，让协议相同
	2. 只有域名不同，让域名相同
	3. 只有端口不同，让端口相同
	4. 不管同不同，直接跳出同源保护策略规则之外，不受跨域规则束缚
```

#### 3. 实际跨域处理方式
```
	1. 无视同源保护政策
		JSONP，利用了script的无视同源保护政策实现，缺点：只能使用get
		
		server Proxy代理，常用
		
		nginx反向代理，常用
		
		cors服务端允许请求，常用
		
		postMessage，处理不同源的iframe父子页面之间的跨域,跨窗口的信息交互

	2. 子域名不同
		document.domain修改子域名
```

### 四、react
#### 1. 生命周期
```
	面试总结：
		组件
		---> 初始化state ---> 渲染前 ---> 创建虚拟dom，进行diff算法 
		---> 渲染完毕 ---> props改变 ---> props或者state改变 
		---> 更新前 ---> 重新渲染dom ---> 更新完毕 
		---> 卸载前

	理解：
		1. 在es6中可以使用constructor，访问this.props,初始化this.state
		2. componentWillMount	组件准备渲染 可以修改state
		3. render				创建虚拟dom，进行diff算法
		4. componentDidMount	组件渲染完毕
		5. componentWillReceiveProps(nextProps)	组件props改变
		6. shouldComponentUpdate(nextProps, nextState)	组件state或props改变, 跟性能优化相关，可以阻止渲染
		7. componentWillUpdata(nextProps, nextState)	组件准备更新，此时可以修改state
		8. render	组件渲染
		9. componentDidUpdate	组件更新完毕，此时可以获取dom节点。
		10. componentWillUnmount	组件将卸载前，一些事件监听和定时器需要在此时清除。
```

#### 2. 技术栈
```
	react + react-dom + react-router + redux或mobx + fetch或axios
	react + react-dom: 核心框架
	react-router: 路由
	redux或mobx: 状态管理
	fecth或axios: http请求相关
	lodash: 工具库
	md5或js-base64或crypto-js或pako: 加解密
	react-loadable： 异步加载,按需加载
	prop-types: 类型检测
	高阶组件: 1. 将组件作为参数，返回新组件(动态生成组件) 2. 给组件添加额外的属性和方法
	refs：用来获取react中的真实DOM
	
	
```

### 五、redux和mobx
#### 1. redux
```

```

#### 2. mobx
```

```

### 六、浏览器缓存 cache-control
```
	面试总结：首部字段 cache-control 可以操作 浏览器缓存的工作机制(是否能缓存，控制可执行缓存的对象，指定缓存期限和认证)
	
	理解：
		是否能缓存
		public: 给所有用户提供缓存
		private: 只给特定用户提供缓存
		no-cache: 防止从缓存中返回过期的资源(并非不缓存，容易误解)
		
		控制可执行缓存的对象
		no-store: 包含机密信息，进制操作
		
		指定缓存期限和认证
		s-maxage: 
		max-age: 
		min-fresh:
		max-stale:
		only-if-cached:
		must-revalidate:
		proxy-revalidate:
		no-transform:
		cache-extension token
		
	
```











	
	







